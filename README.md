### 单例模式
> 单例模式，使某个类的对象仅允许创建一个; 单例模式解决的是如何在整个项目中创建唯一对象实例的问题，工厂模式解决的是如何不通过new建立实例对象的方法
- _instance必须声明为静态的私有变量
- 构造函数和析构函数必须声明为私有,防止外部程序new 类从而失去单例模式的意义
- getInstance()方法必须设置为公有的,必须调用此方法 以返回实例的一个引用
- ::操作符只能访问静态变量和静态函数
- new对象都会消耗内存
- 使用场景:最常用的地方是数据库连接。
- 使用单例模式生成一个对象后， 该对象可以被其它众多对象所使用。
- 私有的__clone()方法防止克隆对象

## 创建型设计模式
### 简单工厂模式
> 简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或实现同一个接口）的实例

> 优点：工厂类是整个模式的关键.包含了必要的逻辑判断,根据外界给定的信息,决定究竟应该创建哪个具体类的对象.通过使用工厂类,外界可以从直接创建具体产品对象的尴尬局面摆脱出来,仅仅需要负责“消费”对象就可以了。而不必管这些对象究竟如何创建及如何组织的．明确了各自的职责和权利，有利于整个软件体系结构的优化

> 缺点：当系统中的具体产品类不断增多时候，可能会出现要求工厂类根据不同条件创建不同实例的需求．这种对条件的判断和对具体产品类型的判断交错在一起，很难避免模块功能的蔓延，对系统的维护和扩展非常不利

> 使用场景：工厂类负责创建的对象比较少；客户只知道传入工厂类的参数，对于如何创建对象（逻辑）不关心；由于简单工厂很容易违反高内聚责任分配原则，因此一般只在很简单的情况下应用。

```
        interfaceDB                     // Product 抽象产品
              |
        |           |
    mysqlDB       sqlserverDB           // Concrete Product   具体产品
        |           |
              |
         SimpleFactory                  // Creater  工厂角色
        
```
### 工厂方法模式
> 工厂模式，工厂方法或者类生成对象，而不是在代码中直接new。使用工厂模式，可以避免当改变某个类的名字或者方法之后，在调用这个类的所有的代码中都修改它的名字或者参数。

### 原型设计模式

## 结构型设计模式
### 适配器模式(Adapter) 类和对象
> 将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原来由于接口不兼容而不能一起工作的类可以一起工作
### 桥接模式 (Bridge)
### 组合模式 (Composite)
### 装饰器模式 (Decorator)
### 外观模式 (Pacade)
### 享元模式 (Flyweight)
### 代理模式 (Proxy)
